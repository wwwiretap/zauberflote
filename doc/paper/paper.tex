\documentclass[letterpaper,twocolumn,10pt]{article}

\usepackage{style, verbatim, url}
\usepackage[colorlinks=true, citecolor=blue]{hyperref}
\usepackage{cleveref, breakurl}

\makeatletter
\newcommand{\crefnames}[3]{
    \@for\next:=#1\do{
        \expandafter\crefname\expandafter{\next}{#2}{#3}
    }
}
\makeatother
\crefnames{part,chapter,section}{\S}{\S\S}

\newcommand{\zbf}{Zauberfl\"{o}te}
\newcommand{\projtitle}{\zbf: A Transparent Peer-to-Peer CDN}

\begin{document}

\title{\Large \bf \projtitle}

\author{
    {\rm Anish Athalye}\\
    aathalye@mit.edu
    \and
    {\rm Ankush Gupta}\\
    ankush@mit.edu
    \and
    {\rm Katie Siegel}\\
    ksiegel@mit.edu
}

\maketitle
\thispagestyle{empty}

\begin{abstract}

\end{abstract}

\section{Introduction}

% TODO Ankush

\section{\zbf\ API}

% TODO Ankush

\section{Implementation}

% Anish

\subsection{Connection manager}

% Anish

\subsection{Download manager}

% Anish

\subsubsection{Chunking}

\zbf\ divides assets into chunks; chunks are individually requested and sent between peers. We use a standard chunk size of 10240 bytes in our implementation; preliminary tests showed this chunk size to be reasonable. When a client asks for a resource, the download manager for that client determines the number of chunks for that resource from the specified size. The download manager then evenly distributes requests for these chunks among the peers with the resource. \\
Requests for chunks time out on a per-chunk basis. We track the time \zbf\ last sent a request for each chunk; if this time exceeds a cutoff, we randomly choose another peer with the resource and send the chunk request to that peer. We periodically retrieve an updated peers list for this resource from the tracker. 

\subsubsection{Hash validation}

% Anish

\subsubsection{Parallelization}

% Anish

\subsubsection{Fault tolerance}

% Anish

\subsection{Tracker interface}

The tracker is hosted on a remote server and tracks client connections. The download manager opens a websocket connection with the remote tracker, which registers the existence of this client. Via this socket, the download manager sends requests for data, specifying a desired resource via that resource's unique SHA1 hash. Upon disconnection, the tracker "forgets" about the client and erases all data about the client's held resources.

\subsection{Signaling channel}

% Katie

\subsection{DOM injection layer}

% Ankush

\section{Evaluation}

% TODO

\section{Future work}

\subsection{Per-chunk hash validation}

% Ankush

\subsection{Hybrid downloads over HTTP and P2P}

% Ankush

\subsection{Variable request sizes}

% Katie

\subsection{Bandwidth detection and prioritization}

% Katie

\subsection{Support for HTML5 media}

% Ankush


\section{Conclusions}

% Katie


{\footnotesize \bibliographystyle{ieeetr}
\bibliography{paper}}

\end{document}
