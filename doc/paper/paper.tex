\documentclass[letterpaper,twocolumn,10pt]{article}

\usepackage{style, verbatim, url, graphicx}
\usepackage[colorlinks=true, citecolor=blue, linkcolor=blue]{hyperref}
\usepackage{caption}
\usepackage{cleveref, breakurl}

\makeatletter
\newcommand{\crefnames}[3]{
    \@for\next:=#1\do{
        \expandafter\crefname\expandafter{\next}{#2}{#3}
    }
}
\makeatother
\crefnames{part,chapter,section}{\S}{\S\S}

\newcommand{\zbf}{Zauberfl\"{o}te}
\newcommand{\projtitle}{\zbf: A Transparent Peer-to-Peer CDN}
\newcommand{\inclfigure}[3]{
    \begin{figure}
        \begin{centering}
            \includegraphics[width=.8\linewidth]{#2}
            \caption{#3}
            \label{#1}
        \end{centering}
    \end{figure}
}

\begin{document}

\title{\Large \bf \projtitle}

\author{
    {\rm Anish Athalye}\\
    aathalye@mit.edu
    \and
    {\rm Ankush Gupta}\\
    ankush@mit.edu
    \and
    {\rm Katie Siegel}\\
    ksiegel@mit.edu
}

\maketitle
\thispagestyle{empty}

\begin{abstract}

\end{abstract}

\section{Introduction}

% TODO Ankush

\section{\zbf\ API}

% TODO Ankush

\section{Implementation}

The \zbf\ architecture consists of several loosely-connected components (see
figure~\ref{fig:components}). At the highest level, there is a download manager that
provides a reliable download service. It relies on the tracker interface and
the connection manager. The tracker interface facilitates communication with
the central tracker for information about peers and file sizes, and the
connection manager provides an interface for peer-to-peer message transfer.

Our components rely on two standard APIs provided by modern browsers,
WebSockets~\cite{w3c:websocket} for client-server communication and
WebRTC~\cite{w3c:webrtc} for peer-to-peer communication.

\inclfigure{fig:components}{components.eps}{
    Relationship between different components of the \zbf\ peer-to-peer
    download service. Components in gray are standard browser APIs.
}

\subsection{Connection manager}

% Anish

\subsection{Download manager}

% Anish

\subsubsection{Chunking}

\zbf\ divides assets into chunks; chunks are individually requested and sent between peers. We use a standard chunk size of 10240 bytes in our implementation; preliminary tests showed this chunk size to be reasonable. When a client asks for a resource, the download manager for that client determines the number of chunks for that resource from the specified size. The download manager then evenly distributes requests for these chunks among the peers with the resource. \\
Requests for chunks time out on a per-chunk basis. We track the time \zbf\ last sent a request for each chunk; if this time exceeds a cutoff, we randomly choose another peer with the resource and send the chunk request to that peer. We periodically retrieve an updated peers list for this resource from the tracker. 

\subsubsection{Hash validation}

% Anish

\subsubsection{Parallelization}

% Anish

\subsubsection{Fault tolerance}

% Anish

\subsection{Tracker interface}

The tracker is hosted on a remote server and tracks client connections. The download manager opens a websocket connection with the remote tracker, which registers the existence of this client. Via this socket, the download manager sends requests for data, specifying a desired resource via that resource's unique SHA1 hash. Upon disconnection, the tracker "forgets" about the client and erases all data about the client's held resources.

\subsection{Signaling channel}

% Katie

\subsection{DOM injection layer}

% Ankush

\section{Evaluation}

% TODO

\section{Future work}

\subsection{Per-chunk hash validation}

% Ankush

\subsection{Hybrid downloads over HTTP and P2P}

% Ankush

\subsection{Variable request sizes}

% Katie

\subsection{Bandwidth detection and prioritization}

% Katie

\subsection{Support for HTML5 media}

% Ankush


\section{Conclusions}

% Katie


{\footnotesize \bibliographystyle{ieeetr}
\bibliography{paper}}

\end{document}
